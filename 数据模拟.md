## 数据模拟：违法交易者识别

我们依照真实比特币交易网络的特点生成了交易纪录模拟数据，并参考 Foley et al. (RFS 2019) 使用的 Smart Local Moving (SLM) 方法，识别出了模拟数据中的违法交易者。关于 SLM 方法的细节请参考报告正文 3.2.2 节。完整代码见 https://github.com/Remi-WANG/SLM-detection。

[TOC]

### 1. 模拟数据生成

现有的比特币违法交易数据表明，违法交易者的大部分交易对象也是违法交易者，普通用户接触到违法交易者的概率较低。基于此，我们选取不同的分布来模拟交易生成过程，以期实现：1）违法交易者之间频繁交易；2）普通用户之间正常交易；3）违法交易者与普通用户之间较少交易。

我们假设交易网络中一共有 200 位参与者。其中前 25 位是违法交易者，而剩下的 175 位是普通用户。对于每一位交易者，我们依次生成其对于其他200位用户之间的交易情况，即一个 1*200 的向量，向量元素为0或者1。该向量每个维度取 1 的概率来自于先验设定的数据生成过程。为了简化生成过程，我们假定交易者自己也有可能和自己发生交易，譬如个人账户之间的转账。这一假定丝毫不影响 SLM 模型的识别效果。我们最终的数据模拟结果是一个 200 * 200 的交易关联网络。

#### 1.1 前25位违法交易者

对于任意一个违法交易者，其发生交易的潜在对象有两类：违法交易者和普通用户。交易者的身份属性是生成一笔交易达成概率的核心变量，我们用 $x$ 表示。

$sigmoid$ 函数经常被用来设定自变量是二分类数据的数据生成过程。在这里，我们使用带随机项的 $sigmoid$ 函数分别生成违法交易者 vs 违法交易者 和 违法交易者 vs 普通用户 这两种配对中两两发生交易的概率。标准形式的 $sigmoid$ 函数$\sigma(x)$ 表达式如下：
$$
\sigma(x) = \frac{1}{1+e^{-x}}
$$
结合 $sigmoid$ 函数单调递增的性质，我们将违法交易者的身份属性 $x$ 定为1，普通交易者的身份属性 $x$ 属性定为 -1。身份矩阵如下：

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20221107192006720.png" alt="image-20221107192006720" style="zoom:33%;" />

我们同时引入一个服从 $i.i.d$ 标准正态分布的随机扰动项 $\epsilon$, 以体现个体情况的异质性。我们据此设计了如下单变量概率生成模型：
$$
P(进行过交易\mid x) = \frac{1}{1+e^{-\beta x+\epsilon}}，\epsilon \sim \mathcal{N}(0,1)
$$
为了保证模拟出的概率数据比较贴近实际情况，我们必须设置一个合适的参数 $\beta$，使得两种概率的期望具有明显的差异性。对于一个 $x$ 服从正态分布 $\mathcal{N}(\mu,\sigma^2)$  的标准形式 $sigmoid$ 函数$\sigma(x)$，其期望如下：
$$
E(\sigma(x))=\int_{-\infty}^{\infty} \sigma(x) \mathcal{N}\left(x \mid \mu, \sigma^2\right) d x=\int_{-\infty}^{\infty} \frac{1}{1+e^{-x}} \frac{1}{\sigma \sqrt{2 \pi}} e^{-\frac{(x-\mu)^2}{2 \sigma^2}} d x
$$
然而，这一积分没有解析表达式，只能采用近似拟合。我们决定借助 $probit$ 函数的性质，用它拟合$sigmoid$ 函数：
$$
\sigma(x) \approx \Phi(\xi x), \text { 其中 } \Phi(x)=\int_{-\infty}^x \mathcal{N}(\theta \mid 0,1) d \theta, \text { 且有 } \xi^2=\frac{\pi}{8}
$$
将这一近似值带回上述积分：
$$
E(\sigma(x)) \approx \int_{-\infty}^{\infty} \Phi(\xi x) \mathcal{N}\left(x\mid\mu, \sigma^2\right) d x
$$
注意到一个自变量为正态分布的 $probit$ 函数的不定积分是一个 $probit$ 函数的值（Ellison. 1964, J.Am.Stat.Assoc, 59, 89-95)，即：
$$
\int \Phi(x) \mathcal{N}\left(x \mid \mu, \sigma^2\right) d x=\Phi\left(\frac{\mu}{\sqrt{1+\sigma^2}}\right)
$$
因此，我们可以得到下列估计量：
$$
\begin{align}
E(\sigma(x)) &\approx \int_{-\infty}^{\infty} \Phi(\xi x) \mathcal{N}\left(\mu, \sigma^2\right) d x=\Phi\left(\frac{\xi \mu}{\sqrt{1+\xi^2 \sigma^2}}\right) \\
&\approx \sigma\left(\frac{\mu}{\sqrt{1+\xi^2 \sigma^2}}\right)=\sigma\left(\frac{\mu}{\sqrt{1+\pi \sigma^2 / 8}}\right)
\end{align}
$$
基于此，研究违法交易者 vs 违法交易者，即 $x=1$时，该类型配对之间发生交易的概率期望为：
$$
E(\frac{1}{1+e^{-(2-\epsilon)}})\approx\sigma\left(\frac{2}{\sqrt{1+\pi  / 8}}\right)\approx0.85
$$
随机生成的100000个样本的样本均值也支持这一拟合值：

```Python
sample = [float(sigmoid(1)) for i in range(100000)]
sum(sample) / len(sample)

# 0.8376134129877996
```

研究违法交易者 vs 合法交易者，即 $x=-1$时，该类型配对之间发生交易的概率期望为：
$$
E(\frac{1}{1+e^{-(-2-\epsilon)}})\approx\sigma\left(\frac{-2}{\sqrt{1+\pi  / 8}}\right)\approx0.15
$$
随机生成的100000个样本的样本均值再一次支持这一拟合值：

```python
sample = [float(sigmoid(-1)) for i in range(100000)]
sum(sample) / len(sample)

# 0.15078507277045153
```

根据该近似结果的指引，我们最终生成的 $sigmoid$ 函数如下：
$$
P(进行过交易\mid x) = \frac{1}{1+e^{-2x+\epsilon}}\\
x \in\{-1,1\}
$$
这一函数对应的无随机项 $sigmoid$ 函数图像（红线）为：

<img src="C:\Users\DELL\Desktop\多维金融风险\虚拟货币\数据模拟\DGP graph.png" alt="DGP graph" style="zoom:30%;" />

与标准形式的 $sigmoid$ 函数（蓝线）相比，我们这里使用的概率生成函数在临界点（0，0.5）附近更加陡峭，这能够强化违法交易者与普通用户之间交易行为的分野。

最终，我们的数据生成过程如下：
$$
trade \sim Bernoulli(\frac{1}{1+e^{-2x+\epsilon}})\\
x \isin\{-1,1\},\epsilon \sim \mathcal{N}(0,1)
$$

#### 1.2 后175位普通用户

现在我们模拟普通用户之间的交易情况，即交易关联网络右上角 175 * 175 的部分。

由于普通用户之间不存在身份异质性，因此我们采用简单的伯努利分布作为数据生成过程。为了增加挑战性，我们将伯努利分布的 $p$ 值设为相对较小的1/3，即该部分的数据生成过程是：
$$
trade \sim Bernoulli(1/3)
$$
这样做的目的是缩小 违法交易者 vs 普通用户 和 普通用户之间的交易密度差距，测试模型控制“错杀”，即 False Positive 错误的能力。

**总而言之，我们设定：1）违法交易者之间两两发生交易的概率是一个均值为70%的随机变量；2）违法交易者与普通用户之间两两发生交易的概率是一个均值为30%的随机变量；3）普通用户之间两两发生交易的概率为33.3%。**

**************

我们最终模拟出的交易网络如下：

<img src="C:\Users\DELL\Desktop\多维金融风险\虚拟货币\数据模拟\network.png" alt="network" style="zoom: 80%;" />

图中蓝色的点表示发生交易的配对，即取值为 1 的格子。可见违法交易者之间（Cluster 2）的点集最稠密；普通用户之间（Cluster 3）次之；违法交易者与普通用户之间（ Cluster 1）与 Cluster 3 相比更加稀疏一些，但密度差距显著小于 Cluster 1 与 Cluster 2。这一设定使得违法交易者的群体较之普通用户群体具有明显更强的封闭性，符合实际情况。

### 2. 识别模型搭建

假设通过警方或者其他各种渠道，在所有的25个违法交易者之中我们可以明确知道前5个。因此现在的任务就是已知前5个是违法交易者的情况下，借助交易关联网络，从剩下的195个用户中识别出其余20个违法交易者，并且尽可能少地 ”滥杀无辜 ”。

依照 SLM 模型的思路，我们遍历每一个用户并考察他的交易对象特点。如果他主要与当前所属群体的用户交易，则可以留在当前群体；如果他主要与另一个群体的用户交易，则将其移动到另一个群体中。在这里我们将判定是否“主要”的临界值设为当前群体用户的数量与用户总数的比例。如果某一个用户的交易中与同群内用户交易的占比（trade proportion）不及该群体用户在总用户中的占比（member proportion），则认为其“不成比例地”与另一个群体的用户开展交易，因此将其挪到另一个群体。

具体实现代码如下：

```python
def community_forming(my_network):

    for i in range(len(my_network)):
        community_candidates = [1,0] 
        # 该用户的交易清单
        trade_record = my_network.iloc[i,:len(my_network)]
    
    	# 当前所属群体
        community = my_network['observed_tag'].iloc[i] 
        # 该群体内的成员名单
        current_member = my_network[my_network['observed_tag']==community].index 
        
        # 总交易次数
        times = len(trade_record[trade_record==1])
        # 交易对象
        correspondence = trade_record[trade_record==1].index.astype('int64')
        # 属于同一群体的交易对象
        within_community_trade = current_member.intersection(correspondence)
    
        trade_proportion = len(within_community_trade) / times
        member_proportion = len(current_member) / len(my_network)
        
        if not trade_proportion > member_proportion:
            # 身份转换
            my_network['observed_tag'].iloc[i] = community_candidates.pop(community)
            
    return my_network['observed_tag']
```

我们将上述函数不断进行迭代，直至群体分类不再发生大的变化，即认为模型达到稳定。我们将稳定状态下的群体分类结果视作最终结果。在具体实现的过程中，我们采用余弦相似度来测度前后两次分类结果向量的相似程度。两个向量 $A,B$ 之间的余弦相似度的定义如下：
$$
\text { cosine similarity }=S_C(A, B):=\cos (\theta)=\frac{\mathbf{A} \cdot \mathbf{B}}{\|\mathbf{A}\|\|\mathbf{B}\|}=\frac{\sum_{i=1}^n A_i B_i}{\sqrt{\sum_{i=1}^n A_i^2} \sqrt{\sum_{i=1}^n B_i^2}}
$$
连续两次结果之间的余弦相似度若大于0.9，则停止迭代。为了避免不收敛的极端情况，我们同时设置了最大迭代次数参数（max_iter) 。

具体实现代码如下：

```python
def SLM(my_network,max_iter):
    last_tag = my_network['observed_tag']
    next_tag = community_forming(network)
    i = 0     
    while 1 - spatial.distance.cosine(last_tag, next_tag) < 0.9 and i < max_iter:
        i += 1
        last_tag = next_tag
        next_tag = community_forming(my_network)
        
    return next_tag
```

### 3. 模型结果评价

在测试中，我们设定 SLM 函数的最大迭代次数为10。

将我们的交易网络放入 SLM 函数中进行迭代运算，最终我们识别出如下违法交易者：

```python
v1 = SLM(network_copy,10)
v1[v1==1].index

# Int64Index([  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,
             13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  34,
             53, 149, 157],
           dtype='int64')
```

可见在完整识别全部真实违法交易者的同时，还“误抓”了4个普通交易者。我们设计了以下函数对识别结果做分类分析：

```python
def perf_measure(y_actual, y_hat):
    TP = 0
    FP = 0
    TN = 0
    FN = 0

    for i in range(len(y_hat)): 
        if y_actual[i]==y_hat[i]==1:
           TP += 1
        if y_hat[i]==1 and y_actual[i]!=y_hat[i]:
           FP += 1
        if y_actual[i]==y_hat[i]==0:
           TN += 1
        if y_hat[i]==0 and y_actual[i]!=y_hat[i]:
           FN += 1

    return(TP, FP, TN, FN)
```

将模型给出的分类结果与真实分类比较，我们可以得到：

True Positive (TP)：25

False Positive (FP)：4

True Negative (TN)：171

False Negative Rate (FN)：0

统计学上经常使用 $F_1$ 得分来衡量二分类模型精确度。它可以看作是模型精确率和召回率的一种调和平均，它的最大值是1，最小值是0：
$$
F_1=2 \cdot \frac{\text { precision } \cdot \text { recall }}{\text { precision }+\text { recall }} \\ 
$$
其中：
$$
precision=\frac{TP}{TP+FP},\text{衡量模型识别正样本的精确度} \\ 
recall = \frac{TP}{TP+FN},\text{衡量模型从真实的正样本中捕获数据的能力}
$$
带入参数，可得本模型的 $F_1$ 得分高达0.93，是一个相当不错的表现。